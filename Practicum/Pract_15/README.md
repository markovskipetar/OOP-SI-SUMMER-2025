## Задача: Реализация на полиморфен интелигентен указател (`polymorphic_ptr`)

Да се реализира шаблонен клас `polymorphic_ptr<T>`, който представлява **умен указател с поддръжка на полиморфизъм** чрез deep copy.

### Цел:

Класът трябва да управлява ресурс от тип `T*` и да поддържа **коректно копиране** на обекти чрез **виртуален метод `clone()`**, дефиниран в базовия клас `T`.

---

### Интерфейс на класа `polymorphic_ptr<T>`

Класът трябва да поддържа следния **интерфейс и поведение**:

#### Конструктори:

- `polymorphic_ptr()` — създава празен указател (нулев).
- `explicit polymorphic_ptr(T* data)` — създава обекта от подаден указател, поема собствеността.
- `polymorphic_ptr(const polymorphic_ptr& other)` — извършва **дълбоко копиране** чрез `clone()`.
- `polymorphic_ptr(polymorphic_ptr&& other)` — премества собствеността без копиране.

#### Оператори за присвояване:

- `polymorphic_ptr& operator=(const polymorphic_ptr& other)` — копира с deep copy.
- `polymorphic_ptr& operator=(polymorphic_ptr&& other)` — премества с move semantics.

#### Деструктор:

#### Оператори за достъп:

- `T* operator->()` и `const T* operator->() const` — достъп до членове на обекта.
- `T& operator*()` и `const T& operator*() const` — достъп до обекта.
- `operator bool() const` — връща `true`, ако указателят не е празен.

#### Допълнителни методи:

- `void reset(T* data)` — замества обекта с нов, освобождавайки стария.
- `T* get()` и `const T* get() const` — достъп до вътрешния указател.
—



# Задача: Реализация на хетерогенен контейнер с помощта на `polymorphic_ptr<T>`

## Описание

Трябва да се реализира клас шаблон `HeterogeneousContainer<T>`, който да поддържа колекция от обекти с различен динамичен тип, наследяващи от базов клас `T`. За управление на паметта и поддържане на полиморфно поведение, в контейнера трябва да се използва класът `polymorphic_ptr<T>`.

## Изисквания

- Класът трябва да използва динамичен масив от обекти от тип `polymorphic_ptr<T>`, без да се използва `std::vector` или други стандартни контейнери.
- Да се реализират:
  - Конструктор по подразбиране.
  - Копиращ конструктор (правещ дълбоко копиране чрез `polymorphic_ptr<T>`).
  - Move конструктор.
  - Деструктор (за правилно освобождаване на паметта).
  - Оператор за присвояване.
  - Оператор за move присвояване.
- Да се осигури функция `push_back`, която добавя нов елемент към контейнера.
- Да се реализират оператори за достъп до елементите по индекс (`operator[]` и `at()`), като `at()` извършва проверка на границите и хвърля изключение при невалиден индекс.
- Да се реализира механизъм за разширяване на капацитета (ресайз), който копира или премества съществуващите елементи в нов, по-голям масив.
- Копирането и местенето на елементите в контейнера трябва да използва функционалността на `polymorphic_ptr<T>`, за да се гарантира правилно полиморфно поведение и управление на ресурсите.

---



